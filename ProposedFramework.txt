My Proposed Framework

	System Setup Phase - Invokes Offline
The service provider (SP) generates two random entropy numbers. 
For a given home gateway (HG) with identification id(gateway), the SP generates the hash of (X, Y), and the hash of (id(gateway), hash of(X)).
The HG then stores the parameters Y, id(gateway), and the one-way hash results.

Hash(X||Y), Hash(id(gateway)||Hash(X))

	Installation Phase
Any given device, with identification id(device), can be used to connect with the HG.
The SP generates a unique authentication token Ua and logs N the number of times a device with identification id(device) requests an installation.
Using these, the SP generates a key K using the hash of (Y, hash of (id(gateway)), hash of (X), Ua).
The parameter Ai should then be generated by the legitimate HG, by encrypting Ek (id(device), N) with the generated K.
Using the id of the HG prevents the device from registering to more than one gateway. It also helps to authenticate genuine transactions.
The parameter Bi can then be generated by the SP by hashing (X, Y) concatenated with Ai.
Given the Bi from a given device, the HG should be able to determine Ai which can be used for the key agreement between the two objects.
The device then stores the parameters of id(gateway), hash of (x), hash of (Ai), Bi, Ua, and id(device) in memory.

K = Hash(Y||Hash(id(gateway)||Hash(X)||Ua)
Ai = EncryptK(id(device)||N)
Bi = (Hash(X||Y) XOR Ai)

	Key Establishment (1)
The first stage of the key establishment occurs from the device to the HG.
The device generates a random number Ra used to compute temporary key parameters between the device and the HG.
The parameter V1 is computed by the device using hash of (id(gateway), hash of (X)), concatenated with Ra, concatenated with timestamp T1.
Parameter CIDi is then generated using Bi, concatenated with the hash of (hash of (id(gateway)||hash of (X))||Ra,T1).
These parameters are used by the key exchange in the following stage to authenticate the transaction using the device identification and transaction timestamp.
The device then generates temporary key Tk using hash of (Ai) concatenated with Ra.
Temporary key Tk is then used in an encryption algorithm ETk(id(device)||id(gateway)||N||Ua||T1) to generate C1.
The device then sends the parameters V1, CIDi, T1, and C1 to the HG.

V1 = Hash(id(gateway)||Hash(X)) XOR Ra XOR T1
CIDi = Bi XOR Hash(Hash(id(gateway)||id(X))||Ra||T1)
Tk = Hash(Ai) XOR Ra
C1 = EncryptK(id(device)||id(gateway)||N||Ua||T1)

	Key Establishment (2)
The second stage of the key establishment occurs from the HG to the device.
Both objects agree on a transmission delay that can be calculated by subtracting the most recent time to the existing one. If the timestamp matches the one agreed, then the transaction should be deemed authentic. This should prevent the likes of replay and duplication attacks.
The HG checks the time, if not true for the delay then the transaction is aborted.
If not, then parameter Ra is computed using V1 concatenated with hash of (id(gateway)||id(device)) concatenated with T2.
Bi is then calculated using CIDi concatenated with hash of (hash of (id (gateway)||id(device))||Ra||T2).
Au is then calculated using Bi concatenated with hash of (X, Y).
The temporary key is then generated using these parameters by means of hashing (Ai) concatenated with Ra.
The temporary key can then be used in a decryption algorithm DTk(C1) to obtain id(device), id(gateway), N, Ua, and T1 from the previous transaction.
Checks are then performed to see if the id(gateway) = id(gateway) and T2 = T1.
The system also checks if id(device) and N by Ai = EncryptK(id(device)||N). -- Not sure
If the checks are positive, then the device is added to a list of legitimate devices.
The HG then defines the shared symmetric key Sk with the device, using the random number Rhg chosen by the HG.
	Sk = Hash(Ra||Rhg||id(device)||id(gateway)||Ua).
For the device to receive and derive the Sk, the HG generates the parameters V2 and C2.
	V2 = Rhg concatenated with Bi concatenated with hash(Ai) concatenated with T3
	C2 = Encryptk(id(gateway), T2, T3
The HG then sends C2, V2, T3 to the device.

T3 - T2 IF true then continue
Ra = V1 XOR Hash(id(gateway)||Hash(X)) XOR T2
Bi = CIDi XOR Hash(Hash(id(gateway)||Hash(X))||Ra||T2)
Ai = Bi XOR Hash(X||Y)
Tk = Hash(Ai) XOR Ra
DTk(C1) $>$ id(device), id(gateway), N, Ua, T2

	Key Establishment (3)
On recieving the message from the HG, the device checks T4 - T3 to see if the time delay still stands.
If the time delay matches, then calculate Rhg using V2 concatenated with Bi concatenated with hash of (Ai) concatenated with T3.
The shared key Sk is then computed using hash of (Ra||Rhg||id(device)||id(gateway)||Ua).
The device then decrypts the message from the HG using the shared key Sk. Decryptk(C2) to obtain id(gateway), T2, T3.
The identification of the gateway is then compared with the id(gateway) and T2 checked against T2 and T3 checked against T3. 
If the three conditions can be verified, then the device assures the HG is an authentic gateway and the Sk can be used to send messages back and forth.

T4 - T3 IF true then continue 
Rhg = V2 XOR Bi XOR Hash(Ai) XOR T3
Sk = Hash(Ra||Rhg||id(device)||id(gateway)||Ua)
DTk(C2) $>$ id(gateway), T2, T3

	Key Persistence
Now the conditions have been authenticated, the device can share the dynamic symmetric session key Sk with the HG to securely send information to the HG. As the information has been hashed and not transmitted in plaintext, the procedure should also be anonymising and achieve the objectives of the dissertation communication between IoT devices in connected living environments.

EncryptSk(message)
DecryptSk(message)